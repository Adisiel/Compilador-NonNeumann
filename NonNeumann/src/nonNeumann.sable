Helpers 
all = [0 .. 0xFFFFF];
lower_case = ['a' .. 'z'];
upper_case = ['A' .. 'Z'];
letter = lower_case | upper_case;
digit = ['0'..'9'];
hex_digit = ['0'..'9']['a'..'f']['A'..'F'];
space = ' ';
underline = '_';
tabulation = 9;
new_line = 10;
carriage_return = 13;
left_brace = '{';
right_brace = '}';
end_of_line = new_line carriage_return | carriage_return | new_line;
not_cr_nl = [all -[carriage_return + new_line]];
not_trace = [all -'-'];
not_trace_brace = [not_trace -[left_brace + right_brace]];

Tokens
true = 'true';
false = 'false';
constant = 'const';
function = 'function';
int = 'int';
bool = 'bool';
real = 'real';
if = 'if';
else = 'else';
then = 'then';
tk_lambda = 'lambda';
and = 'and';
or = 'or';
entry = 'entry';
left_parentheses = '(';
right_parentheses = ')';
equal = '=';
plus =  '+';
minus = '-';
divide = '/';
product = '*';
module = '%';
exclamation = '!';
dot = '.';
comma = ',';
minor = '<';
bigger = '>';
left_bracket = '[';
right_bracket = ']';
colon = ':';
power = '^';
int_hexadecimal = '0''x'(hex_digit)+;
int_decimal = (digit)+;
float= (digit)+ '.' (digit)+;
cientific_notation = (digit)+'E''-'(digit)+ | (digit)+'E'(digit)+;
identifier = ((letter | underline)+(digit | letter)*);
blank = (space | tabulation | end_of_line)+;
line_comment = ';' not_cr_nl* end_of_line;
block_comment = '{-' not_trace* '-'+ (not_trace_brace not_trace* '-'+)* '}';

Ignored Tokens
blank,
line_comment,
block_comment;

Productions 

	program = function_description+;
	
	function_description = entry? left_parentheses function type identifier function_parameters colon function_expression right_parentheses;
	
	function_parameters = left_parentheses parameters* right_parentheses;
	
	function_expression = left_parentheses expression right_parentheses;
	
	type = {int} int
		|{real} real
		|{bool} bool;
		
	parameters = parameter parameters_sequence*;
	
	parameters_sequence = comma parameter;
	
	parameter = {type} type identifier
		|{assign_function} assign_function;
		
	assign_function = type identifier left_parentheses parameters_assign? right_parentheses;
	
	parameters_assign = parameter_assign parameters_assign_sequence*;
	
	parameters_assign_sequence = comma parameter_assign;
	
	parameter_assign = {type} type
		|{assign_function} assign_function;
		
	expression = {operation} operation
		|{gt} expression bigger operation
		|{lt} expression minor operation
		|{equal} expression equal operation
		|{negation} exclamation operation
		|{or} expression or operation
		|{and} expression and operation
		|{if_then_else_statement} if_then_else_statement
		|{lambda} lambda;

	operation = {factor} factor
		|{plus} operation plus factor
  		|{minus} operation minus factor;
			
	factor = {term} term
		|{negative_number} negative_number
		|{mult} factor product term
		|{div} factor divide term
		|{mod} factor module term;
		
	term = {literal} literal 
		|{block_expression} block_expression
		|{call_function} call_function;
			
	negative_number = minus term;
	
	literal = {boolean} boolean_value
		|{float} numeral_float
		|{int} numeral_int
		|{identifier} identifier;
		
	boolean_value = {true} true
		|{false} false;
	
	numeral_float = {float} float
		|{cientific_notation} cientific_notation;
		
	numeral_int = {int_decimal}int_decimal
		|{int_hexadecimal}int_hexadecimal;
	
	block_expression = left_parentheses declaration_constant* expression right_parentheses;
	
	declaration_constant = left_parentheses constant type identifier expression right_parentheses;
	
	call_function = identifier left_parentheses list_expressions? right_parentheses;
		
	lambda = tk_lambda left_parentheses list_identifiers? right_parentheses colon term left_bracket list_expressions? right_bracket;
		
	list_identifiers = identifier list_identifiers_sequence*;
	
	list_identifiers_sequence = comma identifier;
	
	list_expressions = expression list_expressions_sequence*;
		
	list_expressions_sequence = comma expression;
	
	if_then_else_statement = if_statement then term else_statement;
	
	if_statement = if term;
	
	else_statement = else term;
	